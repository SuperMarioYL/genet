# Genet 本地开发配置
# 修改此文件自定义本地调试时的配置

podLimitPerUser: 3
gpuLimitPerUser: 3

gpu:
  availableTypes:
    - name: "NVIDIA A100"
      resourceName: "nvidia.com/gpu"
      nodeSelector:
        gpu-type: "a100"
    - name: "NVIDIA V100"
      resourceName: "nvidia.com/gpu"
      nodeSelector:
        gpu-type: "v100"
  presetImages:
    - name: "test"
      image: "rastasheep/ubuntu-sshd:14.04"
      description: "ssh基础镜像"
    - name: "PyTorch 2.0"
      image: "pytorch/pytorch:2.0.1-cuda11.7-cudnn8-runtime"
      description: "PyTorch 2.0 with CUDA 11.7"

ui:
  defaultTTLHours: 4
  minTTLHours: 1
  maxTTLHours: 24
  enableJupyter: false
  enableCustomImage: true

lifecycle:
  autoDeleteTime: "23:00"
  timezone: "Asia/Shanghai"
  warningThresholdHours: 1

storage:
  # 用户 workspace PVC 配置
  storageClass: "hostpath" # Docker Desktop 使用 hostpath
  size: "10Gi"
  # PVC 访问模式
  # - ReadWriteOnce (RWO): 单节点读写
  # - ReadWriteMany (RWX): 多节点读写（需要 NFS 等支持）
  accessMode: "ReadWriteOnce"

  # 注意：extraVolumes 已废弃，请使用下面的 pod.extraVolumes（K8s 原生格式）
  # extraVolumes: []

# ============================================
# Pod 配置（Kubernetes 原生格式）
# ============================================
# 使用 K8s 标准 YAML 格式，直接参考 K8s 官方文档配置
# 文档: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core
pod:
  # 使用主机网络
  hostNetwork: true

  # DNS 策略（K8s 原生格式）
  # 可选值: ClusterFirst, ClusterFirstWithHostNet, Default, None
  # 当 hostNetwork=true 时，推荐使用 ClusterFirstWithHostNet（默认值）
  dnsPolicy: ClusterFirstWithHostNet

  # 自定义 DNS 配置（可选，当 dnsPolicy 为 None 时必须配置）
  # dnsConfig:
  #   nameservers:
  #     - 8.8.8.8
  #     - 8.8.4.4
  #   searches:
  #     - cluster.local
  #   options:
  #     - name: ndots
  #       value: "5"

  # 资源配置（K8s 原生格式）
  resources:
    requests:
      cpu: "2"
      memory: "4Gi"
    limits:
      cpu: "8"
      memory: "16Gi"

  # 安全上下文（K8s 原生格式）
  securityContext:
    capabilities:
      add:
        - SYS_ADMIN

  # 节点选择器（标签匹配）
  # nodeSelector:
  #   disk: ssd
  #   env: production

  # 亲和性调度（高级规则，K8s 原生格式）
  # 文档: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  # affinity:
  #   nodeAffinity:
  #     # 必须满足的规则（硬约束）
  #     requiredDuringSchedulingIgnoredDuringExecution:
  #       nodeSelectorTerms:
  #         - matchExpressions:
  #             - key: nvidia.com/gpu
  #               operator: Exists
  #     # 优先满足的规则（软约束）
  #     preferredDuringSchedulingIgnoredDuringExecution:
  #       - weight: 80  # 权重 1-100
  #         preference:
  #           matchExpressions:
  #             - key: disk
  #               operator: In
  #               values:
  #                 - ssd
  #                 - nvme
  #       - weight: 50
  #         preference:
  #           matchExpressions:
  #             - key: topology.kubernetes.io/region
  #               operator: In
  #               values:
  #                 - us-west-1
  #                 - us-west-2

  # 额外的存储配置（K8s 原生格式）
  # 注意：用户的 workspace PVC 会自动添加，这里配置额外的存储卷
  # 文档: https://kubernetes.io/docs/concepts/storage/volumes/
  # extraVolumes: []
  # extraVolumeMounts: []
  # 示例配置：
  # extraVolumes:
  #   # PVC 存储
  #   - name: datasets
  #     persistentVolumeClaim:
  #       claimName: shared-datasets
  #       readOnly: true
  #   # HostPath 存储
  #   - name: cache
  #     hostPath:
  #       path: /mnt/cache
  #       type: DirectoryOrCreate
  #   # NFS 存储
  #   - name: models
  #     nfs:
  #       server: nfs.example.com
  #       path: /exports/models
  #       readOnly: true
  #   # ConfigMap
  #   - name: config
  #     configMap:
  #       name: my-config
  #   # Secret
  #   - name: credentials
  #     secret:
  #       secretName: my-secret
  # extraVolumeMounts:
  #   - name: datasets
  #     mountPath: /data/datasets
  #     readOnly: true
  #   - name: cache
  #     mountPath: /data/cache
  #   - name: models
  #     mountPath: /data/models
  #     readOnly: true
  #   - name: config
  #     mountPath: /etc/config
  #   - name: credentials
  #     mountPath: /etc/credentials
  #     readOnly: true

  # 容器启动脚本模板
  # 可用变量: {{.ProxyScript}}
  startupScript: |
    #!/bin/bash
    set -e

    echo "=== Starting Genet Pod ==="

    # 创建必要目录
    mkdir -p /workspace

    # 持久化 VS Code Server 目录（避免每次连接重新下载）
    mkdir -p /workspace/.vscode-server
    rm -rf /root/.vscode-server 2>/dev/null || true
    ln -sf /workspace/.vscode-server /root/.vscode-server
    echo "VS Code Server directory linked to /workspace/.vscode-server"

    {{.ProxyScript}}

    # 显示 GPU 信息（如果有）
    if command -v nvidia-smi &> /dev/null; then
        echo "===== GPU Information ====="
        nvidia-smi || true
    else
        echo "===== CPU Only Mode ====="
    fi

    echo ""
    echo "============================================"
    echo "Pod is ready!"
    echo "============================================"

    # 保持容器运行
    tail -f /dev/null

oauth:
  # OAuth 配置说明：
  # enabled: false - 使用默认用户 dev-user（不需要启动 Mock OAuth）
  # enabled: true  - 启用 OAuth 认证

  enabled: true

  # ============================================
  # 认证模式选择
  # ============================================
  # mode: "oidc" - OIDC 模式（自动发现端点，需配置 providerURL）
  # mode: "oauth" - 纯 OAuth 模式（手动配置端点）
  mode: "oidc"

  # ============================================
  # OIDC 模式配置（mode: "oidc" 时使用）
  # ============================================
  # Mock OAuth2 Server: make mock-oauth-start
  providerURL: "http://localhost:8888/default"

  # ============================================
  # OAuth 模式配置（mode: "oauth" 时使用）
  # ============================================
  # 如果你的 OAuth Provider 不支持 OIDC 发现，使用这些配置：
  authorizationEndpoint: "" # 如: https://auth.internal.com/oauth/authorize
  tokenEndpoint: "" # 如: https://auth.internal.com/oauth/token
  userinfoEndpoint: "" # 如: https://auth.internal.com/api/user（可选）

  # ============================================
  # 用户信息获取方式
  # ============================================
  # userinfoSource: "endpoint" - 从 userinfo API 获取
  # userinfoSource: "token"    - 从 access_token/id_token JWT 解析
  # userinfoSource: "both"     - 优先从 token 解析，失败则调用 endpoint
  userinfoSource: "endpoint"

  # userinfoMethod: userinfo API 的请求方式
  # - "get":  GET 请求 + Authorization: Bearer {token} （标准 OIDC 方式）
  # - "post": POST JSON 请求，body 包含 {client_id, access_token, scope}
  userinfoMethod: "get"

  # 用户信息字段映射（适用于 token 解析和 endpoint 响应）
  # 如果 OAuth Provider 返回的字段名不是标准的，可以通过这两个配置指定
  tokenUsernameClaim: "preferred_username" # 用户名字段，常见值: username, preferred_username, login, user
  tokenEmailClaim: "email" # 邮箱字段，常见值: email, mail, user_email

  # ============================================
  # 公共配置
  # ============================================
  clientID: "genet"
  clientSecret: "genet-secret"
  # 重要：redirectURL 必须指向前端地址，这样 OAuth 回调通过前端代理转发到后端
  # 后端会在前端域（localhost:3000）下设置 cookie，确保后续请求能携带 cookie
  redirectURL: "http://localhost:3000/api/auth/callback"
  frontendURL: "http://localhost:3000"
  scopes:
    - "openid"
    - "profile"
    - "email"
  jwtSecret: "genet-dev-jwt-secret-32chars!!"
  cookieDomain: "" # 空表示当前域
  cookieSecure: false # 本地开发用 http

# ============================================
# 纯 OAuth 模式配置示例（取消注释使用）
# ============================================
# oauth:
#   enabled: true
#   mode: "oauth"
#   authorizationEndpoint: "https://auth.internal.com/oauth/authorize"
#   tokenEndpoint: "https://auth.internal.com/oauth/token"
#   userinfoEndpoint: "https://auth.internal.com/api/user"
#   userinfoSource: "both"
#   userinfoMethod: "post"  # 使用 POST JSON 方式获取用户信息
#   tokenUsernameClaim: "username"
#   tokenEmailClaim: "email"
#   clientID: "your-client-id"
#   clientSecret: "your-client-secret"
#   redirectURL: "http://localhost:3000/api/auth/callback"  # 前端地址
#   frontendURL: "http://localhost:3000"
#   scopes:
#     - "user:read"
#   jwtSecret: "your-jwt-secret-32chars-minimum"
#   cookieDomain: ""
#   cookieSecure: false

# 代理配置（会注入到 Pod 的环境变量和 ~/.bashrc 中）
proxy:
  # HTTP 代理地址，留空则不配置
  httpProxy: ""
  # HTTPS 代理地址，留空则不配置
  httpsProxy: ""
  # 不使用代理的地址列表（逗号分隔）
  noProxy: "localhost,127.0.0.1,.cluster.local"
  # 示例配置：
  # httpProxy: "http://proxy.example.com:8080"
  # httpsProxy: "http://proxy.example.com:8080"
  # noProxy: "localhost,127.0.0.1,.cluster.local,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"

# 镜像仓库配置（用于镜像保存/commit 功能）
registry:
  # 镜像仓库地址，如 registry.example.com 或 docker.io
  url: ""
  # 仓库用户名（可选，用于推送镜像）
  username: ""
  # 仓库密码（可选，用于推送镜像）
  password: ""
  # 示例配置：
  # url: "registry.cn-hangzhou.aliyuncs.com"
  # username: "your-username"
  # password: "your-password"

# 系统依赖镜像配置
images:
  # nerdctl 镜像，用于 commit 操作（将 Pod 保存为镜像）
  nerdctl: "ghcr.io/containerd/nerdctl:v1.7.0"
  # 如果无法访问 ghcr.io，可以替换为其他源：
  # nerdctl: "docker.io/containerd/nerdctl:v1.7.0"
  # nerdctl: "registry.cn-hangzhou.aliyuncs.com/your-namespace/nerdctl:v1.7.0"

# Kubernetes 客户端配置
kubernetes:
  # 禁用 HTTP/HTTPS 代理（推荐在 Windows 系统代理环境下启用）
  # 解决问题：Windows 系统代理导致 K8s API 请求被错误路由
  # true:  K8s API 请求直连，不使用系统代理
  # false: 使用系统代理（默认行为）
  disableProxy: true

  # API 请求超时时间（秒）
  timeout: 30

# ============================================
# OIDC Provider 配置（Genet 作为 OIDC Provider）
# ============================================
# 启用后，Genet 会作为 OIDC Provider，将企业 OAuth 转换为标准 OIDC
# K8s API Server 可以直接信任 Genet，用户可以使用 kubectl 访问集群
oidcProvider:
  enabled: true # 本地开发时可设为 true 进行测试
  # Issuer URL，必须是外部可访问的地址
  # 本地开发时使用: http://localhost:8080
  issuerURL: "http://localhost:8080"
  # RSA 密钥（留空则自动生成）
  rsaPrivateKey: ""
  rsaPublicKey: ""
  # Kubernetes 客户端配置
  kubernetesClientID: "kubernetes"
  kubernetesClientSecret: "kubernetes-secret"

# ============================================
# K8s 集群配置（用于生成 kubeconfig）
# ============================================
cluster:
  name: "local-cluster" # 集群名称
  server: "https://127.0.0.1:6443" # K8s API Server 地址，如: https://localhost:6443
  caData: "" # CA 证书（base64 编码）

# ============================================
# 用户 RBAC 配置
# ============================================
userRBAC:
  enabled: true # 是否启用用户 RBAC 管理
  autoCreate: true # 登录时自动创建用户 Namespace 和 RBAC
