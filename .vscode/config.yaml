# Genet 本地开发配置
# 修改此文件自定义本地调试时的配置

podLimitPerUser: 3
gpuLimitPerUser: 3

gpu:
  availableTypes:
    - name: "NVIDIA A100"
      resourceName: "nvidia.com/gpu"
      nodeSelector:
        gpu-type: "a100"
    - name: "NVIDIA V100"
      resourceName: "nvidia.com/gpu"
      nodeSelector:
        gpu-type: "v100"
  presetImages:
    - name: "test"
      image: "linuxserver/openssh-server"
      description: "ssh基础镜像"
    - name: "PyTorch 2.0"
      image: "pytorch/pytorch:2.0.1-cuda11.7-cudnn8-runtime"
      description: "PyTorch 2.0 with CUDA 11.7"

ui:
  defaultTTLHours: 4
  minTTLHours: 1
  maxTTLHours: 24
  enableJupyter: false
  enableCustomImage: true

lifecycle:
  autoDeleteTime: "23:00"
  timezone: "Asia/Shanghai"
  warningThresholdHours: 1

storage:
  storageClass: "hostpath" # Docker Desktop 使用 hostpath
  size: "10Gi"
  # 额外的通用存储（会挂载到每个 Pod）
  extraVolumes: []
  # 示例配置：
  # extraVolumes:
  #   # PVC 类型（共享数据集）
  #   - name: "datasets"
  #     mountPath: "/data/datasets"
  #     readOnly: true
  #     pvc: "shared-datasets"
  #
  #   # HostPath 类型（本地缓存）
  #   - name: "cache"
  #     mountPath: "/data/cache"
  #     readOnly: false
  #     hostPath: "/mnt/cache"
  #
  #   # NFS 类型（网络存储）
  #   - name: "models"
  #     mountPath: "/data/models"
  #     readOnly: true
  #     nfs:
  #       server: "nfs.example.com"
  #       path: "/exports/models"

oauth:
  # OAuth 配置说明：
  # enabled: false - 使用默认用户 dev-user（不需要启动 Mock OAuth）
  # enabled: true  - 启用 OAuth 认证

  enabled: true

  # ============================================
  # 认证模式选择
  # ============================================
  # mode: "oidc" - OIDC 模式（自动发现端点，需配置 providerURL）
  # mode: "oauth" - 纯 OAuth 模式（手动配置端点）
  mode: "oidc"

  # ============================================
  # OIDC 模式配置（mode: "oidc" 时使用）
  # ============================================
  # Mock OAuth2 Server: make mock-oauth-start
  providerURL: "http://localhost:8888/default"

  # ============================================
  # OAuth 模式配置（mode: "oauth" 时使用）
  # ============================================
  # 如果你的 OAuth Provider 不支持 OIDC 发现，使用这些配置：
  authorizationEndpoint: "" # 如: https://auth.internal.com/oauth/authorize
  tokenEndpoint: "" # 如: https://auth.internal.com/oauth/token
  userinfoEndpoint: "" # 如: https://auth.internal.com/api/user（可选）

  # ============================================
  # 用户信息获取方式
  # ============================================
  # userinfoSource: "endpoint" - 从 userinfo API 获取
  # userinfoSource: "token"    - 从 access_token/id_token JWT 解析
  # userinfoSource: "both"     - 优先从 token 解析，失败则调用 endpoint
  userinfoSource: "endpoint"

  # userinfoMethod: userinfo API 的请求方式
  # - "get":  GET 请求 + Authorization: Bearer {token} （标准 OIDC 方式）
  # - "post": POST JSON 请求，body 包含 {client_id, access_token, scope}
  userinfoMethod: "get"

  # 用户信息字段映射（适用于 token 解析和 endpoint 响应）
  # 如果 OAuth Provider 返回的字段名不是标准的，可以通过这两个配置指定
  tokenUsernameClaim: "preferred_username" # 用户名字段，常见值: username, preferred_username, login, user
  tokenEmailClaim: "email" # 邮箱字段，常见值: email, mail, user_email

  # ============================================
  # 公共配置
  # ============================================
  clientID: "genet"
  clientSecret: "genet-secret"
  # 重要：redirectURL 必须指向前端地址，这样 OAuth 回调通过前端代理转发到后端
  # 后端会在前端域（localhost:3000）下设置 cookie，确保后续请求能携带 cookie
  redirectURL: "http://localhost:3000/api/auth/callback"
  frontendURL: "http://localhost:3000"
  scopes:
    - "openid"
    - "profile"
    - "email"
  jwtSecret: "genet-dev-jwt-secret-32chars!!"
  cookieDomain: "" # 空表示当前域
  cookieSecure: false # 本地开发用 http

# ============================================
# 纯 OAuth 模式配置示例（取消注释使用）
# ============================================
# oauth:
#   enabled: true
#   mode: "oauth"
#   authorizationEndpoint: "https://auth.internal.com/oauth/authorize"
#   tokenEndpoint: "https://auth.internal.com/oauth/token"
#   userinfoEndpoint: "https://auth.internal.com/api/user"
#   userinfoSource: "both"
#   userinfoMethod: "post"  # 使用 POST JSON 方式获取用户信息
#   tokenUsernameClaim: "username"
#   tokenEmailClaim: "email"
#   clientID: "your-client-id"
#   clientSecret: "your-client-secret"
#   redirectURL: "http://localhost:3000/api/auth/callback"  # 前端地址
#   frontendURL: "http://localhost:3000"
#   scopes:
#     - "user:read"
#   jwtSecret: "your-jwt-secret-32chars-minimum"
#   cookieDomain: ""
#   cookieSecure: false

# 代理配置（会注入到 Pod 的环境变量和 ~/.bashrc 中）
proxy:
  # HTTP 代理地址，留空则不配置
  httpProxy: ""
  # HTTPS 代理地址，留空则不配置
  httpsProxy: ""
  # 不使用代理的地址列表（逗号分隔）
  noProxy: "localhost,127.0.0.1,.cluster.local"
  # 示例配置：
  # httpProxy: "http://proxy.example.com:8080"
  # httpsProxy: "http://proxy.example.com:8080"
  # noProxy: "localhost,127.0.0.1,.cluster.local,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"

# 镜像仓库配置（用于镜像保存/commit 功能）
registry:
  # 镜像仓库地址，如 registry.example.com 或 docker.io
  url: ""
  # 仓库用户名（可选，用于推送镜像）
  username: ""
  # 仓库密码（可选，用于推送镜像）
  password: ""
  # 示例配置：
  # url: "registry.cn-hangzhou.aliyuncs.com"
  # username: "your-username"
  # password: "your-password"

# 系统依赖镜像配置
images:
  # nerdctl 镜像，用于 commit 操作（将 Pod 保存为镜像）
  nerdctl: "ghcr.io/containerd/nerdctl:v1.7.0"
  # 如果无法访问 ghcr.io，可以替换为其他源：
  # nerdctl: "docker.io/containerd/nerdctl:v1.7.0"
  # nerdctl: "registry.cn-hangzhou.aliyuncs.com/your-namespace/nerdctl:v1.7.0"

# Kubernetes 客户端配置
kubernetes:
  # 禁用 HTTP/HTTPS 代理（推荐在 Windows 系统代理环境下启用）
  # 解决问题：Windows 系统代理导致 K8s API 请求被错误路由
  # true:  K8s API 请求直连，不使用系统代理
  # false: 使用系统代理（默认行为）
  disableProxy: true

  # API 请求超时时间（秒）
  timeout: 30
